import bs.ModLoader
import bs.SemverUtils
import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import org.apache.ivy.osgi.util.Version

import java.nio.file.Files
import java.nio.file.StandardCopyOption
import static bs.ModLoader.FABRIC
import static bs.ModLoader.FORGE
import static bs.ModLoader.NEOFORGE

plugins {
    id 'java'
}

group = project.properties.mod_package
version = project.properties.mod_version
ModLoader loader = ModLoader.fromProject(project)
archivesBaseName = "${project.properties.mod_id}-$project.properties.minecraft-$loader.friendlyName"

def packageJar = tasks.create("packageJar", Copy.class) {
    into("${rootProject.layout.buildDirectory.get()}/libs/${E.p["mod_version"]}")
}

project.ext["loom.platform"] = loader.friendlyName

repositories {
    mavenCentral()
    // for Mod Menu
    maven {
        url = "https://maven.terraformersmc.com/releases"
    }
	// for Placeholder API
	maven {
		name = 'Nucleoid'
		url = 'https://maven.nucleoid.xyz/'
	}
    // For NeoForge
    maven {
        url = "https://maven.neoforged.net/releases"
    }
    // For NeoForge PRs
    if (project.properties.neoforge_pr) {
        maven {
            url "https://prmaven.neoforged.net/NeoForge/pr$project.properties.neoforge_pr"
            content {
                includeModule("net.neoforged", "neoforge")
            }
        }
    }
    // For Patchment mappings
    if (project.properties.parchment_version) {
        maven {
            name = 'ParchmentMC'
            url = 'https://maven.parchmentmc.org'
        }
    }
    // For Forge
    maven {
        url = "https://maven.minecraftforge.net/"
    }
	// For MineMark
	maven {
		url = "https://maven.dediamondpro.dev/releases"
	}
}
apply plugin: 'dev.architectury.loom'
stonecutter.const("fabric", loader == FABRIC)
stonecutter.const("forge", loader == FORGE)
stonecutter.const("neoforge", loader == NEOFORGE)
loom {
    File file = project.buildDir.toPath().resolve("chiseledSrc/main/resources/${E.p.mod_id}.accesswidener").toFile()
    if (file.exists()) {
        accessWidenerPath = file
    } else {
        project.logger.warn("Access widener file not generated yet!")
    }
}
// Use vanilla mixin on Forge
if (loader == FORGE) {
    loom {
        forge {
            useCustomMixin = false

            mixinConfig "${E.p.mod_id}.mixins.json"
        }
    }
}

dependencies {
    minecraft "net.minecraft:minecraft:$project.properties.minecraft"
    if (project.properties.parchment_version) {
        mappings loom.layered {
            officialMojangMappings()
            parchment("org.parchmentmc.data:parchment-${project.properties.parchment_version}@zip")
        }
    } else {
        mappings loom.officialMojangMappings()
    }
    if (loader == FABRIC) {
        modImplementation "net.fabricmc:fabric-loader:$project.properties.fabricloader"
        modCompileOnly "com.terraformersmc:modmenu:$project.properties.modmenu", {
            // Don't transitively pull in Mod Menu's Fabric deps
            exclude module: "net.fabricmc"
            exclude module: "net.fabricmc.fabric-api"
        }
        modLocalRuntime "com.terraformersmc:modmenu:$project.properties.modmenu", {
            // Don't transitively pull in Mod Menu's Fabric deps
            exclude module: "net.fabricmc"
            exclude module: "net.fabricmc.fabric-api"
        }
        if (project.properties.fabric_api_modules == "*") {
            if (project.properties.include_fabric_api_modules == "true") {
                throw new RuntimeException("You can't include the entirety of Fabric API!")
            }
            modApi "net.fabricmc.fabric-api:fabric-api:$project.properties.fabric_api_version"
        } else {
			if (project.properties.fabric_api_modules) {
				for (String module in project.properties.fabric_api_modules.split(",") as String[]) {
					var dep = fabricApi.module(module, "$project.properties.fabric_api_version")
					modApi dep
					if (project.properties.include_fabric_api_modules == "true") {
						include(dep)
					}
				}
			}
        }
    } else if (loader == FORGE) {
        forge "net.minecraftforge:forge:$project.properties.forge"
    } else if (loader == NEOFORGE) {
        neoForge "net.neoforged:neoforge:$project.properties.neoforge"
    }

	api "dev.dediamondpro:minemark-core:$project.properties.minemark"
	api "org.commonmark:commonmark:$project.properties.commonmark"
	api "org.commonmark:commonmark-ext-gfm-strikethrough:$project.properties.commonmark"
	api "org.commonmark:commonmark-ext-gfm-tables:$project.properties.commonmark"
	api "org.ccil.cowan.tagsoup:tagsoup:$project.properties.tagsoup"
	if (loader == FORGE || loader == NEOFORGE) {
		forgeRuntimeLibrary "dev.dediamondpro:minemark-core:$project.properties.minemark"
		forgeRuntimeLibrary "org.commonmark:commonmark:$project.properties.commonmark"
		forgeRuntimeLibrary "org.commonmark:commonmark-ext-gfm-strikethrough:$project.properties.commonmark"
		forgeRuntimeLibrary "org.commonmark:commonmark-ext-gfm-tables:$project.properties.commonmark"
		forgeRuntimeLibrary "org.ccil.cowan.tagsoup:tagsoup:$project.properties.tagsoup"
	}
//	if (project.name.contains("1.16.5-forge")) {
//		implementation "com.google.code.gson:gson:2.8.0"
//		forgeRuntimeLibrary "com.google.code.gson:gson:2.8.0"
//	}
}

jar {
    from(rootProject.file("LICENSE")) {
        rename { "${it}_${archivesBaseName}"}
    }
}

processResources {
    def dep = project.properties.minecraft_dependency.toString()
    if (loader == FORGE || loader == NEOFORGE) {
        dep = SemverUtils.convertSemverPredicateToMavenPredicate(dep)
    }

    inputs.property "forgeid", loader == NEOFORGE ? "neoforge" : "forge"
    inputs.property "minecraft_dependency", dep
    inputs.property "mod_version", version
    inputs.property "mod_id", project.properties.mod_id
    inputs.property "mod_display_name", project.properties.mod_display_name
    inputs.property "mod_description", project.properties.mod_description
    inputs.property "homepage_url", project.properties.homepage_url
    inputs.property "sources_url", project.properties.sources_url
    inputs.property "issue_tracker_url", project.properties.issue_tracker_url
    inputs.property "license", project.properties.license
    inputs.property "fabricloader", project.properties.fabricloader
    inputs.property "contributors", project.properties.mod_contributors.toString()
    inputs.property "authors", project.properties.mod_authors.toString()
    inputs.property "fabric_api_modules", project.properties.fabric_api_modules

    filesMatching(["fabric.mod.json", "META-INF/mods.toml", "quilt.mod.json"]) {
        def map = [
                "forgeid": loader == NEOFORGE ? "neoforge" : "forge",
                "minecraft": dep,
                "mod_version": version,
                "mod_id": project.properties.mod_id,
                "mod_display_name": project.properties.mod_display_name,
                "mod_description": project.properties.mod_description,
                "homepage_url": project.properties.homepage_url,
                "sources_url": project.properties.sources_url,
                "issue_tracker_url": project.properties.issue_tracker_url,
                "license": project.properties.license,
                "fabricloader": project.properties.fabricloader,
                "contributors": project.properties.mod_contributors.toString().split(","),
                "authors": project.properties.mod_authors.toString().split(",")
        ]
        expand map
    }
    doLast {
        if (loader == NEOFORGE) {
            fileTree(dir: outputs.files.asPath, include: "META-INF/mods.toml").each { File file ->
                file.text += "\n\n[[mixins]]\nconfig = \"${project.properties.mod_id}.mixins.json\""
            }
            fileTree(dir: outputs.files.asPath, include: "META-INF/mods.toml").each { File file ->
                Files.copy(file.toPath(), java.nio.file.Path.of(outputs.files.asPath).resolve("META-INF/neoforge.mods.toml"), StandardCopyOption.REPLACE_EXISTING)
                file.delete()
            }
        }
        if (loader == FABRIC && project.properties.fabric_api_modules) {
            fileTree(dir: outputs.files.asPath, include: "fabric.mod.json").each { File file ->
                def parse = new JsonSlurper().parse(file)
                def fModulesString = project.properties.fabric_api_modules
                if (fModulesString == "*") {
                    parse.depends["fabric-api"] = ">=" + project.properties.fabric_api_version
                } else {
                    def fModules = fModulesString.split(",")
                    for (String s in fModules) {
                        // ^ means until the next major
                        parse.depends[s] = "^" + fabricApi.module(s, project.properties.fabric_api_version).getVersion()
                    }
                }
                file.text = JsonOutput.prettyPrint(JsonOutput.toJson(parse))
            }
        }
    }

    if (loader == FORGE || loader == NEOFORGE) {
        exclude 'fabric.mod.json'
    } else if (loader == FABRIC) {
        exclude 'META-INF/mods.toml', 'META-INF/accesstransformer.cfg', 'pack.mcmeta'
    }
}

remapJar {
    if (loader == FORGE || loader == NEOFORGE) {
        atAccessWideners.add("${project.properties.mod_id}.accesswidener")
    }
}

if (loader == FORGE) {
    configurations.all {
        resolutionStrategy {
            force 'net.sf.jopt-simple:jopt-simple:5.0.4'
        }
    }
}

afterEvaluate {
    packageJar.dependsOn(remapJar)
    packageJar.from(remapJar.archiveFile)
    build.finalizedBy(packageJar)
}

net.fabricmc.loader.api.Version version = net.fabricmc.loader.api.Version.parse(project.properties.minecraft as String)
sourceCompatibility = targetCompatibility = version >= net.fabricmc.loader.api.Version.parse("1.20.5") ? 21 : version >= net.fabricmc.loader.api.Version.parse("1.18") ? 17 : version >= net.fabricmc.loader.api.Version.parse("1.17") ? 16 : 1.8
tasks.withType(JavaCompile).configureEach {
	if (version >= net.fabricmc.loader.api.Version.parse("1.17"))
		options.release = version >= net.fabricmc.loader.api.Version.parse("1.20.5") ? 21 : version >= net.fabricmc.loader.api.Version.parse("1.18") ? 17 : version >= net.fabricmc.loader.api.Version.parse("1.17") ? 16 : 8
}